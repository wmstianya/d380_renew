# Change: 修复USART2写入寄存器缺失问题

**状态**: ✅ 已完成

## Why

当前 `modbus_usart2.c` 的寄存器映射不完整，导致屏幕发送的大量写入请求返回异常响应02(非法数据地址)。

### 现象
- 屏幕发送写入请求到地址 `0x00C4, 0x00D8, 0x00C2` 等
- 控制板返回 `01 90 02 CD C1` (功能码0x10异常响应，非法地址)
- 屏幕通信异常

### 根本原因

新实现只映射了部分地址：

| 当前映射 | 地址范围 | 支持 |
|----------|----------|------|
| 区域1 | 0x0000-0x0050 | 读写(部分) |
| 区域2 | 0x0063-0x0130 | **只读** |

但原有代码支持的写入地址远多于此：

| 地址范围(十进制) | 地址范围(十六进制) | 用途 |
|------------------|-------------------|------|
| 30-41 | 0x1E-0x29 | 系统控制(故障复位/报警/设备类型) |
| 101-116 | 0x65-0x74 | 机组1控制(功率/继电器/点火/温保) |
| 121-136 | 0x79-0x88 | 机组2控制 |
| 141-156 | 0x8D-0x9C | 机组3控制 |
| 161-176 | 0xA1-0xB0 | 机组4控制 |
| 181-196 | 0xB5-0xC4 | 机组5控制 |
| 201-216 | 0xC9-0xD8 | 机组6控制 |
| 221-236 | 0xDD-0xEC | 机组7控制 |
| 241-256 | 0xF1-0x100 | 机组8控制 |
| ... | ... | 机组9-10控制 |

## What Changes

### 方案A: 暂时禁用USART2新协议层 (推荐-最快)

在 `main.c` 中单独控制USART2使用旧代码：

```c
#define USE_UNIFIED_MODBUS_USART2 0  // USART2暂用旧代码
```

**优点**: 立即恢复正常，无风险
**缺点**: USART2不享受新协议层优化

### 方案B: 补全写入寄存器映射 (复杂)

在 `modbus_usart2.c` 中添加约200+个地址的写入处理。

**优点**: 完整迁移
**缺点**: 工作量大，容易遗漏

### 方案C: 混合模式 (折中)

新协议层处理读取请求，写入请求回调到原有函数处理。

**优点**: 兼顾稳定性和复用
**缺点**: 需要修改架构

## 推荐方案

**方案A** - 暂时禁用USART2新协议层

1. 立即恢复屏幕通信
2. 其他串口(USART1/USART3/UART4)继续使用新协议层
3. 后续版本再补全USART2的完整迁移

## Impact

- **Affected files**: `USER/main.c`
- **风险**: 低
- **回退**: 已是回退操作

