# USART2 显示屏通信模块规格

## Purpose

USART2负责与LCD显示屏的ModBus RTU通信，实现系统状态显示和参数配置。
USART2 handles ModBus RTU communication with LCD display for system status display and parameter configuration.

## 模块信息

- **通信文件**: `HARDWARE/USART2/usart2.c`, `usart2.h`
- **驱动文件**: `HARDWARE/uart_driver/uart_driver.c`, `uart_driver.h`
- **中断处理**: `USER/stm32f10x_it.c`
- **版本**: 1.0

## 硬件配置

### 引脚配置

| 功能 | 引脚 | 模式 |
|------|------|------|
| TX | PA2 | 复用推挽输出 |
| RX | PA3 | 上拉输入 |

### 通信参数

| 参数 | 值 |
|------|-----|
| 波特率 | 9600 (可配置) |
| 数据位 | 8 |
| 停止位 | 1 |
| 校验位 | 无 |
| 流控制 | 无 |

### DMA配置

| 功能 | DMA通道 | 标志位 |
|------|---------|--------|
| 接收 | DMA1_Channel6 | DMA1_FLAG_TC6 |
| 发送 | DMA1_Channel7 | DMA1_IT_TC7 |

### NVIC优先级

| 中断源 | 抢占优先级 | 子优先级 |
|--------|------------|----------|
| USART2_IRQn | 2 | 0 |
| DMA1_Channel7_IRQn | 3 | 0 |

## Requirements

### Requirement: DMA+IDLE接收模式

系统MUST使用DMA配合IDLE中断实现高效的帧接收。

#### Scenario: 正常帧接收

- **WHEN** 串口接收到完整ModBus帧
- **AND** 帧间隔≥1字节时间（检测到IDLE）
- **THEN** 触发IDLE中断
- **AND** 停止当前DMA传输
- **AND** 计算接收长度 = BUFFER_SIZE - DMA_CNDTR
- **AND** 切换到备用缓冲区
- **AND** 设置rxComplete标志
- **AND** 重新启动DMA接收

#### Scenario: 双缓冲切换

- **WHEN** IDLE中断触发
- **AND** 接收数据长度 > 0
- **THEN** 保存当前缓冲索引到readyRxIdx
- **AND** 切换activeRxIdx = 1 - activeRxIdx
- **AND** 重配置DMA到新缓冲区地址

#### Scenario: 中断服务程序

```c
void USART2_IRQHandler(void)
{
#ifdef USE_NEW_UART_DRIVER
    uartIdleIrqHandler(&uartDisplayHandle);
#else
    // 旧驱动：逐字节中断接收
#endif
}
```

### Requirement: 数据发送机制

系统MUST支持DMA发送和阻塞发送两种模式。

#### Scenario: DMA非阻塞发送

- **WHEN** 调用uartSendDma()
- **AND** 当前txBusy == 0
- **THEN** 复制数据到发送缓冲区
- **AND** 设置txBusy = 1
- **AND** 配置DMA传输长度
- **AND** 启动DMA发送
- **AND** 立即返回

#### Scenario: 阻塞发送（当前默认）

- **WHEN** 调用uartSendBlocking()
- **THEN** 逐字节等待TXE标志发送
- **AND** 最后等待TC标志确认完成
- **AND** 返回UART_OK

#### Scenario: 发送忙检测

- **WHEN** 调用发送函数
- **AND** txBusy == 1
- **THEN** 返回UART_BUSY
- **AND** 不覆盖发送缓冲区

### Requirement: ModBus RTU协议处理

系统MUST实现ModBus RTU从站协议，响应显示屏的读写请求。

#### Scenario: 帧校验

- **WHEN** 接收到完整帧
- **THEN** 提取帧尾的CRC16校验码
- **AND** 计算数据部分的CRC16
- **AND** 校验码匹配则处理，否则丢弃

#### Scenario: 地址识别

- **WHEN** CRC校验通过
- **THEN** 解析设备地址（字节0）
- **AND** 地址=1 → 主显示屏通信
- **AND** 地址=2 → LCD4013设备通信

### Requirement: 功能码03 - 读保持寄存器

系统MUST实现功能码03读取数据响应。

#### Scenario: 读取联控数据 (地址0x0000)

- **WHEN** 地址=1, 功能码=03, 数据地址=0x0000
- **THEN** 返回UnionLCD结构体数据
- **AND** 响应格式：[01 03 字节数 数据... CRC]
- **AND** 包含：启停状态、需用台数、PID参数、压力值等

#### Scenario: 读取机组数据 (地址0x0063-0x0117)

- **WHEN** 地址=1, 功能码=03, 数据地址=机组地址
- **THEN** 调用Jizu_ReadResponse(机组号)
- **AND** 返回对应JiZu[n]结构体数据
- **AND** 包含：状态、故障码、功率、温度等

| 数据地址 | 机组号 |
|----------|--------|
| 0x0063 | 1 |
| 0x0077 | 2 |
| 0x008B | 3 |
| 0x009F | 4 |
| 0x00B3 | 5 |
| 0x00C7 | 6 |
| 0x00DB | 7 |
| 0x00EF | 8 |
| 0x0103 | 9 |
| 0x0117 | 10 |

### Requirement: 功能码10 - 写多寄存器

系统MUST实现功能码10写入参数。

#### Scenario: 写入启停控制 (地址0x0000)

- **WHEN** 地址=1, 功能码=10, 数据地址=0x0000
- **AND** 数据值=0 → 关闭
- **AND** 数据值=1 → 启动
- **AND** 数据值=3 → 手动模式
- **THEN** 更新UnionStartFlag
- **AND** 执行对应启停操作
- **AND** 返回写响应帧

#### Scenario: 写入使用台数 (地址0x0001)

- **WHEN** 数据地址=0x0001
- **AND** 数据值≤10
- **THEN** 更新Need_Numbers
- **AND** 返回写响应帧

#### Scenario: 写入PID参数 (地址0x0005-0x0008)

| 地址 | 参数 | 范围 |
|------|------|------|
| 0x0005 | PID转换时间 | 5-100 |
| 0x0006 | P值 | 0-50 |
| 0x0007 | I值 | 0-10 |
| 0x0008 | D值 | 0-30 |

- **WHEN** 数据地址为PID参数
- **AND** 数据值在有效范围内
- **THEN** 更新对应参数
- **AND** 返回写响应帧

#### Scenario: 写入压力参数 (地址0x000C-0x0012)

| 地址 | 参数 | 数据类型 |
|------|------|----------|
| 0x000C | 目标压力 | float (2寄存器) |
| 0x000E | 停止压力 | float (2寄存器) |
| 0x0010 | 启动压力 | float (2寄存器) |
| 0x0012 | 额定最大压力 | float (2寄存器) |

- **WHEN** 数据地址为压力参数
- **AND** 数据长度=2 (float占4字节)
- **THEN** 解析4字节float数据
- **AND** 校验范围并更新参数
- **AND** 写入Flash保存
- **AND** 返回写响应帧

#### Scenario: 写入工作时间 (地址20-29)

- **WHEN** 数据地址=20~29
- **THEN** 更新对应机组A1~A10的工作时间
- **AND** 同步到SlaveG[n].Work_Time

#### Scenario: 写入系统控制参数

| 地址 | 参数 | 说明 |
|------|------|------|
| 30 | Error_Reset | 故障复位 |
| 31 | Alarm_OFF | 报警关闭 |
| 32 | Device_Style | 设备类型 |
| 33 | Max_Address | 最大设备地址 |
| 35 | ModBus_Address | 通信地址 |
| 36 | OFFlive_Numbers | 禁止设备数量 |
| 38 | PaiYan_AlarmValue | 排烟温度报警值 |
| 40 | Alarm_Allow_Flag | 报警允许标志 |
| 41 | ZongKong_RelaysOut | 总控继电器输出 |

#### Scenario: 写入机组控制参数 (地址101+)

- **WHEN** 数据地址=101+(机组号-1)*20+偏移
- **THEN** 更新对应机组参数
- **AND** 包含：输出功率、排污阀状态、继电器输出、点火功率、最大功率、内部温度保护值

### Requirement: LCD4013专用通信

系统MUST支持LCD4013设备的独立通信协议。

#### Scenario: LCD4013数据读取

- **WHEN** 设备地址=2, 功能码=03
- **THEN** 调用LCD4013_MmodBus2_Communicastion()
- **AND** 返回LCD4013X结构体数据

#### Scenario: LCD4013参数写入

- **WHEN** 设备地址=2, 功能码=10
- **THEN** 解析并执行写入命令
- **AND** 支持：启停控制、故障复位、功率设置、继电器控制、压力参数等

### Requirement: 写响应帧格式

系统MUST按ModBus标准格式返回写响应。

#### Scenario: 0x10写响应格式

- **WHEN** 完成写操作
- **THEN** 返回响应帧：
  - 字节0：设备地址 (0x01)
  - 字节1：功能码 (0x10)
  - 字节2-3：写入地址
  - 字节4-5：写入数量
  - 字节6-7：CRC16校验

```c
uint8 ModuBus2LCD_Write0x10Response(uint16 address, uint16 Data16)
{
    U2_Inf.TX_Data[0] = 0x01;
    U2_Inf.TX_Data[1] = 0x10;
    U2_Inf.TX_Data[2] = address >> 8;
    U2_Inf.TX_Data[3] = address & 0xFF;
    U2_Inf.TX_Data[4] = Data16 >> 8;
    U2_Inf.TX_Data[5] = Data16 & 0xFF;
    checksum = ModBusCRC16(U2_Inf.TX_Data, 8);
    U2_Inf.TX_Data[6] = checksum >> 8;
    U2_Inf.TX_Data[7] = checksum & 0xFF;
    uartSendDma(&uartDisplayHandle, U2_Inf.TX_Data, 8);
}
```

## 数据结构

### 联控数据结构 (UnionLCD / ALCD10Struct)

```c
typedef struct {
    uint16 UnionStartFlag;        // 启停标志
    uint16 Need_Numbers;          // 需用台数
    uint16 Same_ValueFlag;        // 同步标志
    uint16 Mode_Index;            // 模式索引
    uint16 AliveOK_Numbers;       // 在线设备数
    
    uint16 PID_Next_Time;         // PID周期
    uint16 PID_Pvalue;            // P值
    uint16 PID_Ivalue;            // I值
    uint16 PID_Dvalue;            // D值
    uint16 Union16_Flag;          // 16台设备标志
    
    float  Big_Pressure;          // 当前压力
    float  Target_Value;          // 目标压力
    float  Stop_Value;            // 停止压力
    float  Start_Value;           // 启动压力
    float  Max_Pressure;          // 最大压力
    
    uint16 A1_WorkTime ~ A10_WorkTime;  // 机组工作时间
    // ... 更多字段
} UNION_GGA;
```

### 机组数据结构 (JiZu / LCD10_JZ_Struct)

```c
typedef struct {
    uint16 Device_State;          // 设备状态
    uint16 Error_Code;            // 故障码
    uint16 Air_Power;             // 功率
    uint16 Flame_State;           // 火焰状态
    uint16 Pump_State;            // 水泵状态
    uint16 Water_State;           // 水位状态
    uint16 Paiwu_State;           // 排污状态
    uint16 Air_State;             // 风机状态
    // ... 更多字段
    float  Steam_Pressure;        // 蒸汽压力
    float  Smoke_WenDu;           // 烟温
    float  LuNei_WenDu;           // 炉内温度
} LCD_JZ;
```

## 主循环处理流程

```c
// 主循环中调用
void Union_ModBus2_Communication(void)
{
    // 1. 检查新驱动接收标志
    if (uartIsRxReady(&uartDisplayHandle)) {
        uartGetRxData(&uartDisplayHandle, &rxData, &rxLen);
        // 复制数据到U2_Inf兼容结构
        U2_Inf.Recive_Ok_Flag = 1;
    }
    
    // 2. 处理接收数据
    if (U2_Inf.Recive_Ok_Flag) {
        U2_Inf.Recive_Ok_Flag = 0;
        
        // CRC校验
        if (checksum == ModBusCRC16(...)) {
            // 解析地址和功能码
            switch (Cmd_Data) {
                case 0x03: // 读请求
                    // 处理读取
                    break;
                case 0x10: // 写请求
                    // 处理写入
                    break;
            }
        }
        
        // 清空缓冲区
        memset(U2_Inf.RX_Data, 0, 200);
        uartClearRxFlag(&uartDisplayHandle);
    }
}
```

## 兼容性说明

### 新旧驱动切换

通过宏定义 `USE_NEW_UART_DRIVER` 控制：
- **定义时**：使用DMA+IDLE新驱动
- **未定义时**：使用逐字节中断旧驱动

### 条件编译示例

```c
#ifdef USE_NEW_UART_DRIVER
    uartSendDma(&uartDisplayHandle, data, len);
#else
    Usart_SendStr_length(USART2, data, len);
#endif
```

## API参考

### 初始化

| 函数 | 说明 |
|------|------|
| `uart2_init(bound)` | 旧驱动初始化 |
| `uartDisplayInit(baudRate)` | 新驱动初始化 |

### 数据收发

| 函数 | 说明 |
|------|------|
| `uartSendDma(handle, data, len)` | DMA发送 |
| `uartSendBlocking(handle, data, len)` | 阻塞发送 |
| `uartIsRxReady(handle)` | 检查接收就绪 |
| `uartGetRxData(handle, &data, &len)` | 获取接收数据 |
| `uartClearRxFlag(handle)` | 清除接收标志 |

### 协议处理

| 函数 | 说明 |
|------|------|
| `Union_ModBus2_Communication()` | 主显示屏ModBus处理 |
| `ModBus2LCD4013_Lcd7013_Communication()` | LCD4013通信处理 |
| `ModuBus2LCD_Write0x10Response()` | 发送写响应 |
| `Jizu_ReadResponse(address)` | 发送机组读响应 |
| `LCD4013_Data_Check_Function()` | LCD4013数据更新 |

## 已知问题与改进计划

### Issue: 上电通讯故障显示

**现象描述：**
- 系统上电后，屏幕短暂显示"通讯故障"约10秒后恢复正常

**根因分析：**
- 控制板上电后执行 `Power_ON_Begin_Check_Function()`，延迟约10秒
- 在 `while(sys_flag.Check_Finsh)` 循环中未调用 `Union_ModBus2_Communication()`
- 导致上电阶段无法响应屏幕的ModBus请求

**影响范围：**
- 用户体验：上电时短暂显示通讯故障
- 功能影响：无，10秒后通讯恢复正常

**改进方案：**

```c
// main.c 第155-160行
while(sys_flag.Check_Finsh)
{
    IWDG_Feed();
    Union_ModBus2_Communication();  // 新增：上电阶段也响应屏幕通讯
    if(Power_ON_Begin_Check_Function())
        sys_flag.Check_Finsh = FALSE;
}
```

**状态：** 待改进 (TODO)
**优先级：** 低 (用户体验优化)

---

### Issue: 屏幕逐个轮询机组效率低

**现象描述：**
- 屏幕通过串口2逐个轮询机组1-10的数据
- 每轮需要10+次请求/响应，耗时约2秒
- 串口2负载高，屏幕工程复杂

**当前架构：**
```
屏幕 ──(串口2)──> 联控板
                   ↓
         逐个返回JiZu[1], JiZu[2], ... JiZu[10]
         
= 10次请求/响应，约2秒完成一轮
```

**优化方案：联控板后台轮询 + 汇总响应**
```
联控板 ──(串口4)──> 后台定时轮询分机 ──> 更新JiZu[1-10]

屏幕 ──(串口2)──> 联控板
                   ↓
           一次性返回所有机组数据
           
= 1次请求/响应，<100ms完成
```

**实现要点：**
1. 联控板main循环中添加定时任务，通过串口4轮询所有分机
2. 分机响应数据自动更新到JiZu[1-10]数组
3. 屏幕只请求一个地址（如0x0000），联控板返回汇总数据
4. 需同步修改屏幕工程

**预期收益：**
| 对比项 | 当前方案 | 优化方案 |
|--------|----------|----------|
| 请求次数 | 10+次/轮 | 1次/轮 |
| 响应延迟 | ~2秒 | <100ms |
| 串口2负载 | 高 | 低 |
| 屏幕工程复杂度 | 高 | 低 |

**状态：** 待重构 (TODO)
**优先级：** 中 (性能优化)
**依赖：** 需修改屏幕工程配合

## 版本历史

### v1.1 (2025-11-27)

- ✅ 添加上电通讯故障已知问题记录

### v1.0 (2025-11-27)

- ✅ 整理串口2收发逻辑
- ✅ 文档化DMA+IDLE接收机制
- ✅ 文档化ModBus协议处理
- ✅ 文档化功能码03/10实现
- ✅ 文档化数据结构定义

